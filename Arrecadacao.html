<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>L‑Shaped Storage – 3D Schematic</title>
  <style>
    :root {
      --tile: 34;
      --height: 16;
      --top-fill: #b8cce0;
      --left-fill: #a0bbd4;
      --right-fill: #8fa9c3;
      --stroke: #466c8a;
      --stroke-hi: #8a4a00;

      --top-fill-hi: #ffb77a;
      --left-fill-hi: #ff9d4d;
      --right-fill-hi: #f27e1e;
      --label-color: #123247;
      --label-color-hi: #4a2200;
      --bg: #f6f9fc;
    }

    html, body { height: 100%; }
    body {
      margin: 0; padding: 0;
      background: var(--bg);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color: #0f2a3a;
    }

    .wrap { max-width: 980px; margin: 18px auto 28px; padding: 0 12px; }

    svg { width: 100%; height: auto; display: block; }

    .face { stroke: var(--stroke); stroke-width: .9; }
    .face.top  { fill: var(--top-fill); }
    .face.left { fill: var(--left-fill); }
    .face.right{ fill: var(--right-fill); }

    .hi .face { stroke: var(--stroke-hi); }
    .hi .top  { fill: var(--top-fill-hi); }
    .hi .left { fill: var(--left-fill-hi); }
    .hi .right{ fill: var(--right-fill-hi); }

    .label { font-size: 14px; fill: var(--label-color); font-weight: 700; text-anchor: middle; }
    .hi .label { fill: var(--label-color-hi); }
  </style>
</head>

<body>
  <div class="wrap">
    <!-- Initial viewBox is a safe default; it will be recalculated after drawing -->
    <svg id="scene" viewBox="0 0 740 460" role="img"></svg>
  </div>

  <script>
    (function() {
      const svgNS = 'http://www.w3.org/2000/svg';

      function qp(name) { const u = new URL(window.location.href); return u.searchParams.get(name); }
      function qpInt(name, def) { const v = parseInt(qp(name), 10); return Number.isFinite(v) ? v : def; }
      function qpFloat(name, def) { const v = parseFloat(qp(name)); return Number.isFinite(v) ? v : def; }

      const DEPTH = 6;
      // Back-row width: allow up to 6
      const WIDTH = Math.max(3, Math.min(6, qpInt('w', 3)));

      const tile = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--tile')) || 34;
      const h = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--height')) || 16;

      // Isometric axes
      const ax = { x: tile,  y: -tile/2 };
      const dz = { x: -tile, y: -tile/2 };

      // Anchor points
      const backLeft  = { x: 380, y: 130 }; // Corner of the L (B1 ≡ L6)
      const frontLeft = { x: backLeft.x - dz.x * (DEPTH - 1), y: backLeft.y - dz.y * (DEPTH - 1) };

      const scene = document.getElementById('scene');
      const boxMap = new Map();

      function addPolygon(parent, points, className) {
        const p = document.createElementNS(svgNS, 'polygon');
        p.setAttribute('points', points.map(pt => `${pt.x},${pt.y}`).join(' '));
        p.setAttribute('class', className);
        parent.appendChild(p);
        return p;
      }

      function addText(parent, x, y, txt, className) {
        const t = document.createElementNS(svgNS, 'text');
        t.setAttribute('x', x);
        t.setAttribute('y', y);
        t.setAttribute('class', className);
        t.textContent = txt;
        parent.appendChild(t);
        return t;
      }

      // Accepts either numbers or letters as labels
      function drawIsoBox(origin, key) {
        const p0 = { x: origin.x, y: origin.y };
        the_p1 = { x: origin.x + ax.x,        y: origin.y + ax.y };
        const p2 = { x: origin.x + ax.x + dz.x, y: origin.y + ax.y + dz.y };
        const p3 = { x: origin.x + dz.x,        y: origin.y + dz.y };

        const g = document.createElementNS(svgNS, 'g');
        g.setAttribute('data-n', key);

        addPolygon(g, [p3,p0,{x:p0.x,y:p0.y+h},{x:p3.x,y:p3.y+h}], 'face left');
        addPolygon(g, [p0, the_p1,{x:the_p1.x,y:the_p1.y+h},{x:p0.x,y:p0.y+h}], 'face right');
        addPolygon(g, [p0,the_p1,p2,p3], 'face top');

        const cx = (p0.x + the_p1.x + p2.x + p3.x) / 4;
        const cy = (p0.y + the_p1.y + p2.y + p3.y) / 4 - 3;

        addText(g, cx, cy, key, 'label');

        const title = document.createElementNS(svgNS, 'title');
        title.textContent = key;
        g.appendChild(title);

        scene.appendChild(g);
        return g;
      }

      // Draw back row (B2..B[WIDTH] → numbered 5 + j)
      for (let j = WIDTH; j >= 2; j--) {
        const origin = { x: backLeft.x + ax.x * (j - 1), y: backLeft.y + ax.y * (j - 1) };
        const num = 5 + j;
        const g = drawIsoBox(origin, num);
        boxMap.set(num, g);
      }

      // Corner B1 ≡ L6 → 6
      {
        const origin = { x: backLeft.x, y: backLeft.y };
        const g = drawIsoBox(origin, 6);
        boxMap.set(6, g);
      }

      // Left column L5..L1 → 5..1
      for (let i = DEPTH - 1; i >= 1; i--) {
        const origin = { x: frontLeft.x + dz.x * (i - 1), y: frontLeft.y + dz.y * (i - 1) };
        const g = drawIsoBox(origin, i);
        boxMap.set(i, g);
      }

      // ---- Lettered boxes (shifted): a,c at former b,d positions; b,d moved further right ----
      (function drawLetterGridShifted() {
        // Spacing config (in "tile" units)
        const gapX = qpFloat('gapx', 0.6);   // horizontal gap between columns
        const gapY = qpFloat('gapy', 0.6);   // vertical gap between rows
        const clearUnits = qpFloat('clear', 1.6); // clearance from the L corner toward the elbow

        // Base: push inside the elbow, away from the L along -dz
        const start = {
          x: backLeft.x + (-dz.x * clearUnits),
          y: backLeft.y + (-dz.y * clearUnits)
        };

        // Column step along +ax with horizontal gap
        const colStep = {
          x: ax.x * (1 + gapX),
          y: ax.y * (1 + gapX)
        };

        // Row step toward elbow interior along -dz with vertical gap
        const rowStep = {
          x: -dz.x * (1 + gapY),
          y: -dz.y * (1 + gapY)
        };

        // Explicit placement:
        // a -> row 0, col 1
        // b -> row 0, col 2
        // c -> row 1, col 1
        // d -> row 1, col 2
        const placements = [
          { key: 'a', r: 0, c: 1 },
          { key: 'b', r: 0, c: 2 },
          { key: 'c', r: 1, c: 1 },
          { key: 'd', r: 1, c: 2 },
        ];

        for (const { key, r, c } of placements) {
          const origin = {
            x: start.x + colStep.x * c + rowStep.x * r,
            y: start.y + colStep.y * c + rowStep.y * r
          };
          const g = drawIsoBox(origin, key);
          boxMap.set(key, g); // allow highlighting via ?n=a|b|c|d
        }
      })();
      // -----------------------------------------------------------------------------------

      // Highlight via ?n= (supports numbers and letters)
      (function applyHighlight() {
        const nParam = qp('n');
        if (nParam == null) return;

        const nNum = parseInt(nParam, 10);
        if (Number.isFinite(nNum) && boxMap.has(nNum)) {
          boxMap.get(nNum).classList.add('hi');
          return;
        }

        if (boxMap.has(nParam)) {
          boxMap.get(nParam).classList.add('hi');
        }
      })();

      // Auto-fit the SVG viewBox so everything remains visible
      try {
        const bb = scene.getBBox();
        const pad = 24; // breathing room for strokes/labels
        const vb = [
          Math.floor(bb.x - pad),
          Math.floor(bb.y - pad),
          Math.ceil(bb.width + pad * 2),
          Math.ceil(bb.height + pad * 2),
        ].join(' ');
        scene.setAttribute('viewBox', vb);
      } catch (e) {
        // Fallback: widen viewBox proportionally if WIDTH increased
        const baseW = 740;
        const extra = Math.max(0, WIDTH - 4) * tile * 2; // heuristic extension
        scene.setAttribute('viewBox', `0 0 ${baseW + extra} 460`);
      }
    })();
  </script>
</body>
</html>
